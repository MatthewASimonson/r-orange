#summary A brief description of the structure of our widgets and what they do.

= Introduction =

Red attempts to facilitate the use of R by providing a wrapper for common functions and redesigning the entire R work flow from that of sequential function calling to that of a streamlined information processing.  As such, Red uses the orange platform to generate work flows (more on the underlying RStructure later).  These work flows can be re-used or modified at any point.  Once changed orange will resend the output of the widgets to be processed downstream.  Because of the computational requirements some of our widgets do not run "on connect" or "on reconnect".  Instead they destroy any downstream outputs once data is reconnected to them.  These widgets must be reprocessed but once processed the data output will proceed automatically until another "kill" call is encountered.  

This platform has many advantages over other GUI based R interaction environments.  To begin with the power of the Qt package can be used for graphics and data interaction to a degree not realized in the R environment or environments relying on Tk.  Another advantage is the access to the rich package repositories of python for data editing and interaction.  Widgets and work flows are very easy to generate and most R functions can be incorporated with ease.

This interface is designed to bring the power of the R statistical environment to the general researcher or user.  As such widgets are designed to operate with a minimum of expertise with every attempt being made to automate criteria selection and to make the many underlying operations invisible to the user.  With that said, this environment is proving useful to even experienced R users because of it's ease in work flow generation and simplicity of processing.  In our experience, often one will want to perform the same task repeatedly on different sets of data (subset -> merge data -> statistical calculation -> subset on significant criteria -> (visualize, record output, save data)).  To achieve this with any reasonable speed one would normally write a function and make multiple calls to that function, a process that may take much time to troubleshoot and would be immutable (an interesting finding would make the user perform the tasks again outside of the function to collect the variables to interrogate).  In r-orange this can be done easily, repeatedly, and at any point other widgets may be connected to those on the canvas for further data mining.

==!RStructure==

In many ways Red attempls to be a sophisticated GUI for R.  As opposed to other systems which call GUI's from R, Red calls GUI's from python which send commands to R.  In this way the power of R for data manipulation can be exploited along with the programming and GUI abilities of Python.  

Red GUI's recieve and output to eachother simple pointers to R variables which exist in R.  Once a GUI recieves this variable it may make calls to R, recieve output, and use this output to populate the GUI.  For example ColumnSelector uses the recieved variable to obtain a list of row and column names for subestting.  These are used to populate lists so the user can interact with row infromation for subsetting.  

The infromation sent between widgets in Red can be much more complicated than a single pointer to a variable.  Widgets actually send Python objects called dict's which have keys for data.  In red all widgets must send and recieve dicts with an element named "data" which will be interpreted by other widgets as the primary input for processing.  This component is mandatory to be included in the Red framework.  However, widgets may send as an output any other kind of meta data the author may want to include.  Widgets in the Bioconductor package make ample use of this by sending data about classification, processing methods, phenotypic infromation, links to root data elements, etc.  So long as they connect to a widget that 'looks' for that data element the meta-data can be used to populate the widget.  By convention, widget authors are asked to make data that is obtained in the meta-data section also an input area on the GUI or to make the widget fail if the input data is not complete (the widget requires meta-data but none is available).  Also care should be taken to be aware of meta-data that may be passed by widgets.  Authors may wish to negate meta-data by sending a fresh dict as an output instead of modifying the data of an existing dict.

==Data Processing==

In theory the majority of data processing occurs at the R level.  Preprocessing logic carried out at the Python level should eventually result in a command that is sent to R.  For example:

-----
plot widget

recieve two vector names: x and y

python level: 
 check if x and y represent number variables and have the same length
 show the numbers to the user
 make a command like plot(x=x, y=y)
 send to R

R level:
 plot(x=x, y=y)
-----

Actual processing may be much more complex than this requiring many commands to be executed at the R level followed by post processing to make a vector that can easily interface with other widgets.  Authors are encouraged to make widgets that send one of the common R variable types (data.frame, list, vector) and make any other output of the widget either meta-data or a seperate output of the widget.  This practice makes moving from one package to another much easier and the user will generally get something that resembles what they want.