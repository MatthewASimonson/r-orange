#summary Introduction to the RRGUI functions
#labels Phase-Design,Phase-Implementation

= Introduction =

QT widget classes can not be saved as they are instances of an object, however, their attributes may be saved and reloaded using QT functionality.  This document discribes the basic classes of objects that can be 'naturally' saved in RedR.  All QT objects are 'legal' for the widget maker however methods for loading and saving of these classes will have to be writen manually and is not recomended.

= Details =

GUI elements should be called through the RRGUI classes of functions so that RedR saving and loading funcitonality will apply to those GUI elements.  Behind the scenes, these functions instantiate either QT or OWGUI (children of QT) widgets with the addition of a widgetattr.  The widget call should be of the form:
{{{
self.myWidget = RRGUI.widget(widget, 'myWidget', self, ...)
}}}
This will add 'myWidget' to a list of deep attributes for the loading and saving funcitonality of RedR to handle.

Supplying a None in plase of 'myWidget' will exempt this widget from the saving and loading functionality.  This is desirable if the widget should be called but not assigned to a variable for manipulation.  Ideally these widgets will not be modified during the session (for example, buttons and widget boxes). 

Currently, the following widgets are available for inclusion in the RRGUI class:
  * widget Boxes
  * widget Labels
  * check Boxes
  * line Edits
  * buttons
  * list boxes
  * radio buttons in box
  * comboBoxes
  * combo box with caption
  * tab widgets
  * tab widget pages
  * tables
  * text edits

===A note on when not to use===

Under the hood, these widgets make a connection to the widget class attribute (called myWidget above) and place that attribute in a list that is cheched during saving time.  
Attributes about that widget (items in cells, text, checked status, selected status, etc.) are checked during save and recorded into a file.  On reloading this file is checked and the widgets are repopulated with the saved infromation.  

If the widget is using R as its statistical engine it is likely that infromaiton that is displayed in the widget will actually be repeated infromation that is stored with the R image, also created at save time.  Functionality such as displaying a summary of some data in a text edit box would be less memory consuming if the widget simply called an internal function to redisplay the text after sending a query to R (make R process the data again instead of saving the data).  Usually this is not a problem as the memory consumed by small text edits and line edits is negligable, however if one is saving very large tables the memory consumption gets exponentially larger.  

Therefore, in some cases, it is advised to write custom methods for saving and loading to widgets that will repopulate the widget data on reload.  To exempt a RRGUI widget from inclusion in the save list simply replace the 'myWidget' section in the example above with None.  For example:
{{{
self.myWidget = RRGUI.widget(widget, None, self, ...)

Then write custom reload functions such as:

def onCustomReload(self):
  relement = self.R('rFunction('+self.Rvariables['myRVariable']+')')
  for element in relement:
    self.myWidget.setMyAttribute(_index_, element)
}}}
It is important to note that even if the widgetattr is set to the save list, this method may be employed to set widget attributes that are not part of the normal saving and loading of RRGUI widgets (pointers to icons or background colors for example).